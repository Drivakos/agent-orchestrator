import os
import json
import re
import subprocess
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process, LLM
from crewai_tools import FileReadTool, FileWriterTool, SerperDevTool
from src.tools import CodeExecutionTool, SyntaxCheckTool

load_dotenv()

# --- Configuration ---
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "https://llm.drivakosv.gr/v1")
MODEL_NAME = "openai/qwen3:8b" 
API_KEY = os.getenv("OPENAI_API_KEY")

class CrewEngine:
    def __init__(self, project_name="default_project", init_git=False, remote_url=None):
        self.project_name = project_name
        self.base_dir = os.path.join("projects", project_name)
        self.output_dir = os.path.join(self.base_dir, "code")
        self.memory_file = os.path.join(self.base_dir, "memory.md")
        self.metadata_file = os.path.join(self.base_dir, "project_metadata.json")
        
        # Ensure directories exist
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Initialize Tools
        self.file_writer = FileWriterTool()
        self.file_reader = FileReadTool()
        self.code_tool = CodeExecutionTool(working_dir=self.output_dir)
        self.syntax_tool = SyntaxCheckTool(working_dir=self.output_dir)
        self.search_tool = None
        
        if os.getenv("SERPER_API_KEY"):
            try:
                self.search_tool = SerperDevTool()
            except Exception as e:
                print(f"[Engine] Warning: Could not initialize SerperDevTool: {e}")
        
        # Initialize LLM
        self.llm = LLM(
            model=MODEL_NAME,
            base_url=OLLAMA_BASE_URL,
            api_key=API_KEY,
            extra_headers={
                "User-Agent": "Mozilla/5.0",
                "Authorization": f"Bearer {API_KEY}"
            }
        )
        
        if init_git:
            self._initialize_git_repo(remote_url)

    def _initialize_git_repo(self, remote_url=None):
        """Initializes a git repository and creates metadata."""
        repo_exists = os.path.exists(os.path.join(self.base_dir, ".git"))
        
        if not repo_exists:
            try:
                # Initialize Git
                subprocess.run(["git", "init"], cwd=self.base_dir, check=True, capture_output=True)
                
                # Create default metadata
                metadata = {
                    "name": self.project_name,
                    "description": "Generated by CrewAI Agent Orchestrator",
                    "version": "0.1.0",
                    "branch": "main"
                }
                with open(self.metadata_file, 'w') as f:
                    json.dump(metadata, f, indent=4)

                # Create .gitignore
                with open(os.path.join(self.base_dir, ".gitignore"), 'w') as f:
                    f.write("__pycache__/\n*.pyc\n")

                # Initial Commit
                subprocess.run(["git", "add", "."], cwd=self.base_dir, check=True, capture_output=True)
                subprocess.run(["git", "commit", "-m", "chore: initial commit"], cwd=self.base_dir, check=True, capture_output=True)
                
                # Ensure branch is main
                subprocess.run(["git", "branch", "-m", "main"], cwd=self.base_dir, capture_output=True)
                
            except Exception as e:
                print(f"[Engine] Error initializing git: {e}")
                return

        # Handle Remote URL (whether new or existing repo)
        if remote_url:
            try:
                # Check if remote exists
                result = subprocess.run(["git", "remote"], cwd=self.base_dir, capture_output=True, text=True)
                if "origin" not in result.stdout:
                    subprocess.run(["git", "remote", "add", "origin", remote_url], cwd=self.base_dir, check=True, capture_output=True)
                    subprocess.run(["git", "push", "-u", "origin", "main"], cwd=self.base_dir, check=True, capture_output=True)
            except Exception as e:
                print(f"[Engine] Error adding remote: {e}")

    def get_project_metadata(self):
        """Reads project metadata."""
        if os.path.exists(self.metadata_file):
            try:
                with open(self.metadata_file, 'r') as f:
                    return json.load(f)
            except Exception:
                return None
        return None

    def _commit_changes(self, user_story):
        """Increments version and commits changes."""
        if not os.path.exists(os.path.join(self.base_dir, ".git")):
            return

        try:
            # Update Version
            metadata = self.get_project_metadata()
            version = "unknown"
            if metadata:
                v_parts = metadata.get("version", "0.1.0").split('.')
                if len(v_parts) == 3:
                    v_parts[-1] = str(int(v_parts[-1]) + 1) # Patch increment
                metadata["version"] = ".".join(v_parts)
                version = metadata["version"]
                
                with open(self.metadata_file, 'w') as f:
                    json.dump(metadata, f, indent=4)

            # Git Commit
            subprocess.run(["git", "add", "."], cwd=self.base_dir, check=True, capture_output=True)
            commit_msg = f"feat: {user_story} (v{version})"
            subprocess.run(["git", "commit", "-m", commit_msg], cwd=self.base_dir, check=True, capture_output=True)
            
            # Push Changes
            self._push_changes()

        except Exception as e:
            print(f"[Engine] Error committing changes: {e}")

    def _push_changes(self):
        """Pushes changes to remote if configured."""
        try:
            # Check if remote exists
            result = subprocess.run(["git", "remote"], cwd=self.base_dir, capture_output=True, text=True)
            if "origin" in result.stdout:
                 # Get current branch
                branch_res = subprocess.run(["git", "branch", "--show-current"], cwd=self.base_dir, capture_output=True, text=True)
                branch = branch_res.stdout.strip()
                
                subprocess.run(["git", "push", "origin", branch], cwd=self.base_dir, check=True, capture_output=True)
        except Exception as e:
            print(f"[Engine] Push warning: Could not push to remote. {e}")

    def _get_file_tree(self):
        """Generates a string representation of the project file structure."""
        tree_str = "\n## Current File Structure:\n"
        start_path = self.base_dir
        
        for root, dirs, files in os.walk(start_path):
            # Modify dirs in-place to skip hidden directories and specific folders
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != "__pycache__" and d != "venv"]
            
            level = root.replace(start_path, '').count(os.sep)
            indent = '  ' * level
            if level > 0:
                base_name = os.path.basename(root)
                tree_str += f"{indent}{base_name}/\n"
            
            subindent = '  ' * (level + 1)
            for f in files:
                if not f.startswith('.'):
                    tree_str += f"{subindent}{f}\n"
                    
        return tree_str

    def _get_memory_context(self):
        """Reads the memory file and appends file structure to provide context."""
        context = ""
        if os.path.exists(self.memory_file):
            with open(self.memory_file, 'r', encoding='utf-8') as f:
                context = f.read()
        else:
            context = "No previous features implemented yet."
            
        # Append File Tree
        context += "\n" + self._get_file_tree()
        return context

    def _update_memory(self, user_story, result):
        """Appends the new feature to the memory file."""
        entry = f"\n## Implemented Feature: {user_story}\n\n**Result Summary:**\n{result}\n\n---\n"
        with open(self.memory_file, 'a', encoding='utf-8') as f:
            f.write(entry)

    def process_message(self, user_input):
        """Decides whether to chat or run a task based on user input."""
        intent = self._classify_intent(user_input)
        
        if intent == "CHAT":
            return self._chat_with_pm(user_input)
        else:
            return self.run(user_input)

    def _classify_intent(self, user_input):
        """Classifies the user input as 'CHAT' or 'TASK'."""
        classifier = Agent(
            role='Intent Classifier',
            goal='Classify user input.',
            backstory="You are a classifier. You distinguish between conversational questions/requests for info versus tasks that require code changes.",
            allow_delegation=False,
            verbose=False,
            llm=self.llm
        )
        
        task = Task(
            description=f"Classify this input: '{user_input}'.\nReturn ONLY the word 'CHAT' if it's a question or request for information (e.g. 'how do I...', 'explain...').\nReturn ONLY the word 'TASK' if it requires implementing a feature, writing code, or modifying the project (e.g. 'add...', 'fix...', 'create...').",
            expected_output="One word: CHAT or TASK",
            agent=classifier
        )
        
        crew = Crew(agents=[classifier], tasks=[task], verbose=False)
        result = crew.kickoff()
        return str(result).strip().upper()

    def _chat_with_pm(self, user_input):
        """Runs a chat session with the Product Manager using context."""
        memory_context = self._get_memory_context()
        
        # Prepare tools for PM if available
        pm_tools = []
        if self.search_tool:
            pm_tools.append(self.search_tool)
        
        pm_agent = Agent(
            role='Product Manager',
            goal=f'Provide information about project "{self.project_name}".',
            backstory=f"""You are the Technical PM for "{self.project_name}".
            
            **Current Project Status (Memory):**
            {memory_context}
            
            Answer the user's question based on the existing project state and your general knowledge.
            If you need to check the web for latest info, use your Search Tool.
            Do not propose new implementation plans unless asked.""",
            verbose=True,
            allow_delegation=False,
            tools=pm_tools,
            llm=self.llm
        )
        
        task = Task(
            description=f"User Question: '{user_input}'\nProvide a helpful, informative answer.",
            expected_output="A conversational response.",
            agent=pm_agent
        )
        
        crew = Crew(agents=[pm_agent], tasks=[task], verbose=True)
        return str(crew.kickoff())

    def run(self, user_story):
        """Executes the Crew for a specific user story with memory context."""
        
        memory_context = self._get_memory_context()
        
        # --- Prepare Tools ---
        pm_tools = []
        dev_tools = [self.file_writer, self.syntax_tool] # Developer gets syntax checker
        
        if self.search_tool:
            pm_tools.append(self.search_tool)
            dev_tools.append(self.search_tool)

        # --- Agents ---
        pm_agent = Agent(
            role='Product Manager',
            goal=f'Plan features for the project "{self.project_name}".',
            backstory=f"""You are the Technical PM for "{self.project_name}".
            
            **Current Project Status (Memory):**
            {memory_context}
            
            Your job is to plan the implementation of: '{user_story}'
            Ensure it integrates with existing features.
            Use your Search Tool if you need to research external APIs or libraries.""",
            verbose=True,
            allow_delegation=False,
            tools=pm_tools,
            llm=self.llm
        )

        dev_agent = Agent(
            role='Senior Developer',
            goal='Write code and output it in Markdown blocks.',
            backstory=f"""You are the Lead Dev. 
            **CRITICAL:** Output files using this EXACT format:
            ### filename.py
            ```python
            print("hello")
            ```
            Relative paths should be based on the project root.
            
            1. Write the code to files using the format above.
            2. Use the 'Syntax Checker' tool on your new files to check for errors.
            3. Fix any syntax errors BEFORE finishing. 
            
            Use your Search Tool if you run into errors or need documentation.""",
            verbose=True,
            allow_delegation=False,
            tools=dev_tools,
            llm=self.llm
        )

        qa_agent = Agent(
            role='QA Engineer',
            goal='Write unit tests.',
            backstory="You are the QA. Write tests for the new code.",
            verbose=True,
            allow_delegation=False,
            tools=[self.file_writer],
            llm=self.llm
        )
        
        runner_agent = Agent(
            role='DevOps Engineer',
            goal='Execute code and tests to verify functionality.',
            backstory="""You are the DevOps Engineer. You run the code and tests using the Code Executor tool and report the results.
            **CRITICAL:** Do NOT attempt to run long or complex Python code using 'python -c'. 
            If you need to run tests or code, ensure the Senior Developer or QA Engineer has written them to a file first. 
            Then, use the Code Executor to run 'pytest <filename>' or 'python <filename>'.
            """,
            verbose=True,
            allow_delegation=False,
            tools=[self.code_tool],
            llm=self.llm
        )
        
        docs_agent = Agent(
            role='Documentation Specialist',
            goal='Update project documentation.',
            backstory="You are responsible for keeping the documentation up to date. You document the new features and how to use them.",
            verbose=True,
            allow_delegation=False,
            tools=[self.file_writer],
            llm=self.llm
        )

        reviewer_agent = Agent(
            role='Chief Architect',
            goal='Review and Approval.',
            backstory="""Review the work. Check the source code, tests, AND the test execution results provided by the DevOps Engineer.
            Use the 'Syntax Checker' tool if you suspect valid syntax issues.
            If tests failed or the code is buggy/invalid, REJECT it.
            """,
            verbose=True,
            allow_delegation=True,
            tools=[self.syntax_tool], # Reviewer gets syntax checker
            llm=self.llm
        )

        # --- Tasks ---
        task_plan = Task(
            description=f"""
            Plan the feature: '{user_story}'. 
            Consider the existing memory: {memory_context}.
            
            **Brainstorming Phase:**
            1. Generate 3 distinct implementation approaches (e.g., different libraries, patterns, or algorithms).
            2. List Pros/Cons for each.
            3. Select the BEST approach.
            
            **Final Output:**
            Provide the detailed implementation plan for the selected approach.
            """,
            expected_output="Implementation plan with brainstorming summary.",
            agent=pm_agent
        )

        task_dev = Task(
            description="""
            Write the code based on the plan. 
            Use '### filename' format.
            
            **Self-Critique Phase:**
            1. Draft the code.
            2. Review your draft for logical errors, security issues, and style.
            3. Fix any issues. 
            
            Output the FINAL corrected code.
            """,
            expected_output="Source code in markdown.",
            agent=dev_agent,
            context=[task_plan]
        )

        task_qa = Task(
            description="Write tests.",
            expected_output="Test code in markdown.",
            agent=qa_agent,
            context=[task_dev]
        )
        
        task_runner = Task(
            description="Execute the tests using 'pytest' or run the main script. Report the STDOUT and STDERR.",
            expected_output="Execution logs and pass/fail status.",
            agent=runner_agent,
            context=[task_qa]
        )
        
        task_docs = Task(
            description="Create or update 'README.md' or 'CHANGELOG.md' to reflect the new feature and how to run it.",
            expected_output="Documentation content.",
            agent=docs_agent,
            context=[task_plan, task_dev, task_runner]
        )

        task_review = Task(
            description="""
            Review the code, tests, EXECUTION RESULTS, and DOCUMENTATION.
            If tests failed, you MUST REJECT.
            If everything looks good, start your response with "APPROVED".
            If there are issues, start your response with "REJECTED" and list the specific feedback/issues that need fixing.
            """,
            expected_output="Verdict (APPROVED or REJECTED with feedback).",
            agent=reviewer_agent,
            context=[task_plan, task_dev, task_qa, task_runner, task_docs]
        )

        crew = Crew(
            agents=[pm_agent, dev_agent, qa_agent, runner_agent, docs_agent, reviewer_agent],
            tasks=[task_plan, task_dev, task_qa, task_runner, task_docs, task_review],
            process=Process.sequential,
            verbose=True
        )

        try:
            result = crew.kickoff()
        except Exception as e:
            error_msg = f"Crew execution failed: {str(e)}"
            print(f"\n[Engine] Error: {error_msg}")
            return error_msg

        self._save_files_from_output(crew)

        # --- Iterative Feedback Loop ---
        max_iterations = 3
        iteration = 0
        
        while "REJECTED" in str(result).upper() and iteration < max_iterations:
            iteration += 1
            print(f"\n[Engine] Review rejected. Starting Iteration {iteration}/{max_iterations} for fixes...")
            
            # Feedback from the previous review
            feedback = str(result)
            
            # New Tasks for the Fix Cycle
            task_fix = Task(
                description=f"""
                The previous submission was REJECTED.
                
                **Reviewer Feedback:**
                {feedback}
                
                Fix the code and/or tests to address the feedback.
                Output the FULL updated files using '### filename' format.
                """,
                expected_output="Fixed source code in markdown.",
                agent=dev_agent
            )

            task_qa_fix = Task(
                description="Update or add tests for the fixed code.",
                expected_output="Updated test code in markdown.",
                agent=qa_agent,
                context=[task_fix]
            )
            
            task_runner_fix = Task(
                description="Run the updated tests.",
                expected_output="Execution logs.",
                agent=runner_agent,
                context=[task_qa_fix]
            )

            task_review_fix = Task(
                 description="""
                Review the FIXED code, tests, and NEW execution results.
                If satisfied, start with "APPROVED".
                If still issues, start with "REJECTED".
                """,
                expected_output="Verdict (APPROVED or REJECTED).",
                agent=reviewer_agent,
                context=[task_fix, task_qa_fix, task_runner_fix]
            )
            
            fix_crew = Crew(
                agents=[dev_agent, qa_agent, runner_agent, reviewer_agent],
                tasks=[task_fix, task_qa_fix, task_runner_fix, task_review_fix],
                process=Process.sequential,
                verbose=True
            )
            
            try:
                result = fix_crew.kickoff()
            except Exception as e:
                error_msg = f"Fix cycle execution failed: {str(e)}"
                print(f"\n[Engine] Error: {error_msg}")
                return error_msg

            self._save_files_from_output(fix_crew)
        
        if "REJECTED" in str(result).upper():
            print("\n[Engine] Maximum iterations reached. Final result is still REJECTED.")
        else:
            print("\n[Engine] Feature APPROVED.")

        # Update memory and commit (using the final result)
        self._update_memory(user_story, str(result))
        
        # Auto-commit if git is enabled
        self._commit_changes(user_story)
        
        return str(result)

    def _save_files_from_output(self, crew):
        """Parses output from all tasks and saves files to the project code directory."""
        for task in crew.tasks:
            if not task.output: continue
            
            # Markdown Parsing
            pattern = r'###\s+([^\n]+)\s+```[^\n]*\n(.*?)\n```'
            matches = re.finditer(pattern, str(task.output), re.DOTALL)
            
            for match in matches:
                filename = match.group(1).strip()
                content = match.group(2)
                
                # Remove redundant paths if agent added them
                clean_filename = filename.replace('output/', '').replace('code/', '')
                full_path = os.path.join(self.output_dir, clean_filename)
                
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
