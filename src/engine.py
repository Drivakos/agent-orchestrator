import os
import json
import re
import subprocess
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process, LLM
from crewai_tools import FileReadTool, FileWriterTool

load_dotenv()

# --- Configuration ---
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "https://llm.drivakosv.gr/v1")
MODEL_NAME = "openai/qwen3:8b" 
API_KEY = os.getenv("OPENAI_API_KEY")

class CrewEngine:
    def __init__(self, project_name="default_project", init_git=False, remote_url=None):
        self.project_name = project_name
        self.base_dir = os.path.join("projects", project_name)
        self.output_dir = os.path.join(self.base_dir, "code")
        self.memory_file = os.path.join(self.base_dir, "memory.md")
        self.metadata_file = os.path.join(self.base_dir, "project_metadata.json")
        
        # Ensure directories exist
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Initialize Tools
        self.file_writer = FileWriterTool()
        self.file_reader = FileReadTool()
        
        # Initialize LLM
        self.llm = LLM(
            model=MODEL_NAME,
            base_url=OLLAMA_BASE_URL,
            api_key=API_KEY,
            extra_headers={
                "User-Agent": "Mozilla/5.0",
                "Authorization": f"Bearer {API_KEY}"
            }
        )
        
        if init_git:
            self._initialize_git_repo(remote_url)

    def _initialize_git_repo(self, remote_url=None):
        """Initializes a git repository and creates metadata."""
        repo_exists = os.path.exists(os.path.join(self.base_dir, ".git"))
        
        if not repo_exists:
            try:
                # Initialize Git
                subprocess.run(["git", "init"], cwd=self.base_dir, check=True, capture_output=True)
                
                # Create default metadata
                metadata = {
                    "name": self.project_name,
                    "description": "Generated by CrewAI Agent Orchestrator",
                    "version": "0.1.0",
                    "branch": "main"
                }
                with open(self.metadata_file, 'w') as f:
                    json.dump(metadata, f, indent=4)

                # Create .gitignore
                with open(os.path.join(self.base_dir, ".gitignore"), 'w') as f:
                    f.write("__pycache__/\n*.pyc\n")

                # Initial Commit
                subprocess.run(["git", "add", "."], cwd=self.base_dir, check=True, capture_output=True)
                subprocess.run(["git", "commit", "-m", "chore: initial commit"], cwd=self.base_dir, check=True, capture_output=True)
                
                # Ensure branch is main
                subprocess.run(["git", "branch", "-m", "main"], cwd=self.base_dir, capture_output=True)
                
            except Exception as e:
                print(f"[Engine] Error initializing git: {e}")
                return

        # Handle Remote URL (whether new or existing repo)
        if remote_url:
            try:
                # Check if remote exists
                result = subprocess.run(["git", "remote"], cwd=self.base_dir, capture_output=True, text=True)
                if "origin" not in result.stdout:
                    subprocess.run(["git", "remote", "add", "origin", remote_url], cwd=self.base_dir, check=True, capture_output=True)
                    subprocess.run(["git", "push", "-u", "origin", "main"], cwd=self.base_dir, check=True, capture_output=True)
            except Exception as e:
                print(f"[Engine] Error adding remote: {e}")

    def get_project_metadata(self):
        """Reads project metadata."""
        if os.path.exists(self.metadata_file):
            try:
                with open(self.metadata_file, 'r') as f:
                    return json.load(f)
            except Exception:
                return None
        return None

    def _commit_changes(self, user_story):
        """Increments version and commits changes."""
        if not os.path.exists(os.path.join(self.base_dir, ".git")):
            return

        try:
            # Update Version
            metadata = self.get_project_metadata()
            version = "unknown"
            if metadata:
                v_parts = metadata.get("version", "0.1.0").split('.')
                if len(v_parts) == 3:
                    v_parts[-1] = str(int(v_parts[-1]) + 1) # Patch increment
                metadata["version"] = ".".join(v_parts)
                version = metadata["version"]
                
                with open(self.metadata_file, 'w') as f:
                    json.dump(metadata, f, indent=4)

            # Git Commit
            subprocess.run(["git", "add", "."], cwd=self.base_dir, check=True, capture_output=True)
            commit_msg = f"feat: {user_story} (v{version})"
            subprocess.run(["git", "commit", "-m", commit_msg], cwd=self.base_dir, check=True, capture_output=True)
            
            # Push Changes
            self._push_changes()

        except Exception as e:
            print(f"[Engine] Error committing changes: {e}")

    def _push_changes(self):
        """Pushes changes to remote if configured."""
        try:
            # Check if remote exists
            result = subprocess.run(["git", "remote"], cwd=self.base_dir, capture_output=True, text=True)
            if "origin" in result.stdout:
                 # Get current branch
                branch_res = subprocess.run(["git", "branch", "--show-current"], cwd=self.base_dir, capture_output=True, text=True)
                branch = branch_res.stdout.strip()
                
                subprocess.run(["git", "push", "origin", branch], cwd=self.base_dir, check=True, capture_output=True)
        except Exception as e:
            print(f"[Engine] Push warning: Could not push to remote. {e}")

    def _get_file_tree(self):
        """Generates a string representation of the project file structure."""
        tree_str = "\n## Current File Structure:\n"
        start_path = self.base_dir
        
        for root, dirs, files in os.walk(start_path):
            # Modify dirs in-place to skip hidden directories and specific folders
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != "__pycache__" and d != "venv"]
            
            level = root.replace(start_path, '').count(os.sep)
            indent = '  ' * level
            if level > 0:
                base_name = os.path.basename(root)
                tree_str += f"{indent}{base_name}/\n"
            
            subindent = '  ' * (level + 1)
            for f in files:
                if not f.startswith('.'):
                    tree_str += f"{subindent}{f}\n"
                    
        return tree_str

    def _get_memory_context(self):
        """Reads the memory file and appends file structure to provide context."""
        context = ""
        if os.path.exists(self.memory_file):
            with open(self.memory_file, 'r', encoding='utf-8') as f:
                context = f.read()
        else:
            context = "No previous features implemented yet."
            
        # Append File Tree
        context += "\n" + self._get_file_tree()
        return context

    def _update_memory(self, user_story, result):
        """Appends the new feature to the memory file."""
        entry = f"\n## Implemented Feature: {user_story}\n\n**Result Summary:**\n{result}\n\n---\n"
        with open(self.memory_file, 'a', encoding='utf-8') as f:
            f.write(entry)

    def process_message(self, user_input):
        """Decides whether to chat or run a task based on user input."""
        intent = self._classify_intent(user_input)
        
        if intent == "CHAT":
            return self._chat_with_pm(user_input)
        else:
            return self.run(user_input)

    def _classify_intent(self, user_input):
        """Classifies the user input as 'CHAT' or 'TASK'."""
        classifier = Agent(
            role='Intent Classifier',
            goal='Classify user input.',
            backstory="You are a classifier. You distinguish between conversational questions/requests for info versus tasks that require code changes.",
            allow_delegation=False,
            verbose=False,
            llm=self.llm
        )
        
        task = Task(
            description=f"Classify this input: '{user_input}'.\nReturn ONLY the word 'CHAT' if it's a question or request for information (e.g. 'how do I...', 'explain...').\nReturn ONLY the word 'TASK' if it requires implementing a feature, writing code, or modifying the project (e.g. 'add...', 'fix...', 'create...').",
            expected_output="One word: CHAT or TASK",
            agent=classifier
        )
        
        crew = Crew(agents=[classifier], tasks=[task], verbose=False)
        result = crew.kickoff()
        return str(result).strip().upper()

    def _chat_with_pm(self, user_input):
        """Runs a chat session with the Product Manager using context."""
        memory_context = self._get_memory_context()
        
        pm_agent = Agent(
            role='Product Manager',
            goal=f'Provide information about project "{self.project_name}".',
            backstory=f"""You are the Technical PM for "{self.project_name}".
            
            **Current Project Status (Memory):**
            {memory_context}
            
            Answer the user's question based on the existing project state and your general knowledge.
            Do not propose new implementation plans unless asked.""",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )
        
        task = Task(
            description=f"User Question: '{user_input}'\nProvide a helpful, informative answer.",
            expected_output="A conversational response.",
            agent=pm_agent
        )
        
        crew = Crew(agents=[pm_agent], tasks=[task], verbose=True)
        return str(crew.kickoff())

    def run(self, user_story):
        """Executes the Crew for a specific user story with memory context."""
        
        memory_context = self._get_memory_context()
        
        # --- Agents ---
        pm_agent = Agent(
            role='Product Manager',
            goal=f'Plan features for the project "{self.project_name}".',
            backstory=f"""You are the Technical PM for "{self.project_name}".
            
            **Current Project Status (Memory):**
            {memory_context}
            
            Your job is to plan the implementation of: '{user_story}'
            Ensure it integrates with existing features.""",
            verbose=True,
            allow_delegation=False,
            llm=self.llm
        )

        dev_agent = Agent(
            role='Senior Developer',
            goal='Write code and output it in Markdown blocks.',
            backstory=f"""You are the Lead Dev. 
            Output files using this format:
            ### filename
            ```language
            code
            ```
            Relative paths should be based on the project root.
            """,
            verbose=True,
            allow_delegation=False,
            tools=[self.file_writer],
            llm=self.llm
        )

        qa_agent = Agent(
            role='QA Engineer',
            goal='Write unit tests.',
            backstory="You are the QA. Write tests for the new code.",
            verbose=True,
            allow_delegation=False,
            tools=[self.file_writer],
            llm=self.llm
        )

        reviewer_agent = Agent(
            role='Chief Architect',
            goal='Review and Approval.',
            backstory="""Review the work. Ensure it matches the memory and requirements.
            You have the power to REJECT the work if it's incomplete, buggy, or lacks tests.
            If REJECTED, the team will have to fix it.
            """,
            verbose=True,
            allow_delegation=True,
            llm=self.llm
        )

        # --- Tasks ---
        task_plan = Task(
            description=f"Plan the feature: '{user_story}'. Consider the existing memory: {memory_context}.",
            expected_output="Implementation plan.",
            agent=pm_agent
        )

        task_dev = Task(
            description="Write the code. Use '### filename' format.",
            expected_output="Source code in markdown.",
            agent=dev_agent,
            context=[task_plan]
        )

        task_qa = Task(
            description="Write tests.",
            expected_output="Test code in markdown.",
            agent=qa_agent,
            context=[task_dev]
        )

        task_review = Task(
            description="""
            Review the code and tests.
            If everything looks good, start your response with "APPROVED".
            If there are issues, start your response with "REJECTED" and list the specific feedback/issues that need fixing.
            """,
            expected_output="Verdict (APPROVED or REJECTED with feedback).",
            agent=reviewer_agent,
            context=[task_plan, task_dev, task_qa]
        )

        crew = Crew(
            agents=[pm_agent, dev_agent, qa_agent, reviewer_agent],
            tasks=[task_plan, task_dev, task_qa, task_review],
            process=Process.sequential,
            verbose=True
        )

        result = crew.kickoff()
        self._save_files_from_output(crew)

        # --- Iterative Feedback Loop ---
        max_iterations = 3
        iteration = 0
        
        while "REJECTED" in str(result).upper() and iteration < max_iterations:
            iteration += 1
            print(f"\n[Engine] Review rejected. Starting Iteration {iteration}/{max_iterations} for fixes...")
            
            # Feedback from the previous review
            feedback = str(result)
            
            # New Tasks for the Fix Cycle
            task_fix = Task(
                description=f"""
                The previous submission was REJECTED.
                
                **Reviewer Feedback:**
                {feedback}
                
                Fix the code and/or tests to address the feedback.
                Output the FULL updated files using '### filename' format.
                """,
                expected_output="Fixed source code in markdown.",
                agent=dev_agent
            )

            task_qa_fix = Task(
                description="Update or add tests for the fixed code.",
                expected_output="Updated test code in markdown.",
                agent=qa_agent,
                context=[task_fix]
            )

            task_review_fix = Task(
                 description="""
                Review the FIXED code and tests.
                If satisfied, start with "APPROVED".
                If still issues, start with "REJECTED".
                """,
                expected_output="Verdict (APPROVED or REJECTED).",
                agent=reviewer_agent,
                context=[task_fix, task_qa_fix]
            )
            
            fix_crew = Crew(
                agents=[dev_agent, qa_agent, reviewer_agent],
                tasks=[task_fix, task_qa_fix, task_review_fix],
                process=Process.sequential,
                verbose=True
            )
            
            result = fix_crew.kickoff()
            self._save_files_from_output(fix_crew)
        
        if "REJECTED" in str(result).upper():
            print("\n[Engine] Maximum iterations reached. Final result is still REJECTED.")
        else:
            print("\n[Engine] Feature APPROVED.")

        # Update memory and commit (using the final result)
        self._update_memory(user_story, str(result))
        
        # Auto-commit if git is enabled
        self._commit_changes(user_story)
        
        return str(result)

    def _save_files_from_output(self, crew):
        """Parses output from all tasks and saves files to the project code directory."""
        for task in crew.tasks:
            if not task.output: continue
            
            # Markdown Parsing
            pattern = r'###\s+([^\n]+)\s+```[^\n]*\n(.*?)\n```'
            matches = re.finditer(pattern, str(task.output), re.DOTALL)
            
            for match in matches:
                filename = match.group(1).strip()
                content = match.group(2)
                
                # Remove redundant paths if agent added them
                clean_filename = filename.replace('output/', '').replace('code/', '')
                full_path = os.path.join(self.output_dir, clean_filename)
                
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
